/*
 * Imports
 */
#include <FEHLCD.h>
#include <FEHIO.h>
#include <FEHUtility.h>
#include <FEHMotor.h>
#include <FEHRPS.h>
#include <math.h>
#include <FEHServo.h>
#include <FEHBattery.h>
#include <FEHRPS.h>
#include <FEHSD.h>

/*
 * Variables
 */
#define COUNTS_PER_INCH_8 1.01859
#define COUNTS_PER_INCH_16 2.03718
#define COUNTS_PER_INCH_32 4.07437

#define COUNTS_PER_TURN_16 1.01859

#define TIME_INCH .13
#define TIME_ROTATE 0.80

#define OPTO_THRESHOLD 2.0
#define RED_RANGE 0.27
#define BLUE_RANGE 0.55

// servo constants
#define MINARM1 728
#define MAXARM1 2437
#define MINARM2 728
#define MAXARM2 2430

/*
 * Encoders
 */
DigitalEncoder encoder_Right(FEHIO::P0_0);
DigitalEncoder encoder_Left(FEHIO::P1_0);
/*
 * Motors for wheels
 */
FEHMotor motor_RightWheel(FEHMotor::Motor0,9.0);
FEHMotor motor_LeftWheel(FEHMotor::Motor1,9.0);
/*
 * Input for lights
 */
AnalogInputPin input_Light(FEHIO::P0_1);

/*
 * Input for optosensors
 */
AnalogInputPin input_leftOpto(FEHIO::P0_2);
AnalogInputPin input_middleOpto(FEHIO::P1_2);
AnalogInputPin input_rightOpto(FEHIO::P2_2);

/*
 * Servos for arm
 */
FEHServo servo_Arm1(FEHServo::Servo0);
FEHServo servo_Arm2(FEHServo::Servo1);

/*
 * Class Location
 */
class Location {
    public:
        Location(double, double, double);
        double getX();
        double getY();
        double getHeading();
    private:
        double x;
        double y;
        double heading;
};

Location::Location(double inX, double inY, double inHeading) {
    x = inX;
    y = inY;
    heading = inHeading;
}

double Location::getX() {
    return x;
}

double Location::getY() {
    return y;
}

double Location::getHeading() {
    return heading;
}



/*
 * =============================================
 * Movement
 * =============================================
 */

void moveForward_Time(int percent, double distance) {
    motor_RightWheel.SetPercent(percent);
    motor_LeftWheel.SetPercent(percent);
    Sleep(distance * TIME_INCH);
    motor_RightWheel.Stop();
    motor_LeftWheel.Stop();
}

void moveBackward_Time(int percent, double distance) {
    motor_RightWheel.SetPercent(-1 * percent);
    motor_LeftWheel.SetPercent(-1 * percent);
    Sleep(distance * TIME_INCH);
    motor_RightWheel.Stop();
    motor_LeftWheel.Stop();
}

void turnRight_Time(int percent, double distance) {
    motor_RightWheel.SetPercent(-1 * percent);
    motor_LeftWheel.SetPercent(percent);
    Sleep(distance * TIME_ROTATE);
    motor_RightWheel.Stop();
    motor_LeftWheel.Stop();
}

void turnLeft_Time(int percent, double distance) {
    motor_RightWheel.SetPercent(percent);
    motor_LeftWheel.SetPercent(-1 * percent);
    Sleep(distance * TIME_ROTATE);
    motor_RightWheel.Stop();
    motor_LeftWheel.Stop();
}

void moveForward(int percent, double distance) {
    encoder_Right.ResetCounts();
    encoder_Left.ResetCounts();
    motor_RightWheel.SetPercent(percent);
    motor_LeftWheel.SetPercent(percent);
    // For 16 counts
    while ((encoder_Left.Counts() < (distance * COUNTS_PER_INCH_16)) && (encoder_Right.Counts() < (distance * COUNTS_PER_INCH_16))) {
    }
    motor_RightWheel.Stop();
    motor_LeftWheel.Stop();
}

void moveBackward(int percent, double distance) {
    encoder_Right.ResetCounts();
    encoder_Left.ResetCounts();
    motor_RightWheel.SetPercent(-1 * percent);
    motor_LeftWheel.SetPercent(-1 * percent);
    // For 16 counts
    while ((encoder_Left.Counts() < (distance * COUNTS_PER_INCH_16)) && (encoder_Right.Counts() < (distance * COUNTS_PER_INCH_16))) {
    }
    motor_RightWheel.Stop();
    motor_LeftWheel.Stop();
}

void turnRight(int percent, double turns) {
    encoder_Right.ResetCounts();
    encoder_Left.ResetCounts();
    motor_RightWheel.SetPercent(-1 * percent);
    motor_LeftWheel.SetPercent(percent);
    // For 16 counts
    while ((encoder_Left.Counts() < (turns * COUNTS_PER_TURN_16)) && (encoder_Right.Counts() < turns * COUNTS_PER_TURN_16)) {
    }
    motor_RightWheel.Stop();
    motor_LeftWheel.Stop();
}

void turnLeft(int percent, double turns) {
    encoder_Right.ResetCounts();
    encoder_Left.ResetCounts();
    motor_RightWheel.SetPercent(percent);
    motor_LeftWheel.SetPercent(-1 * percent);
    // For 16 counts
    while ((encoder_Left.Counts() < (turns * COUNTS_PER_TURN_16)) && (encoder_Right.Counts() < turns * COUNTS_PER_TURN_16)) {
    }
    motor_RightWheel.Stop();
    motor_LeftWheel.Stop();
}

/*
 * RPS
 */
void rps_MoveToPositiveX(int percent, float x) {
    while((RPS.X() > 0) && (RPS.X() < x - 0.2 || RPS.X() > x + 0.2)) {
        if (RPS.X() < x) {
            moveForward_Time(percent, 0.1);
        } else if (RPS.X() > x) {
            moveBackward_Time(percent, 0.1);
        }
    }
}

void rps_MoveToNegativeX(int percent, float x) {
    while ((RPS.X() > 0) && (RPS.X() < x - 0.2 || RPS.X() > x + 0.2)) {
        if (RPS.X() > x) {
            moveForward_Time(percent, 0.1);
        } else if (RPS.X() < x) {
            moveBackward_Time(percent, 0.1);
        }
    }
}

void rps_MoveToPositiveY(int percent, float y) {
    while ((RPS.Y() > 0) && (RPS.Y() < y - 0.2 || RPS.Y() > y + 0.2)) {
        if (RPS.Y() < y) {
            moveForward_Time(percent, 0.1);
        } else if (RPS.Y() > y) {
            moveBackward_Time(percent, 0.1);
        }
    }
}

void rps_MoveToNegativeY(int percent, float y) {
    while ((RPS.Y() > 0) && (RPS.Y() < y - 0.2 || RPS.Y() > y + 0.2)) {
        if (RPS.Y() > y) {
            moveForward_Time(percent, 0.1);
        } else if (RPS.Y() < y) {
            moveBackward_Time(percent, 0.1);
        }
    }
}

void rps_checkHeading(float heading) {
    bool aligned = false;
    while (!aligned) {
        double headingActual = RPS.Heading();
        if (heading <= 1.0) {
            if (headingActual > 340) {
                headingActual -= 360.0;
            }
        }

        if (fabs(heading - headingActual) < 0.5) {
            aligned = true;
        } else {
            if (headingActual > heading) {
                // turn slightly to the left
                turnRight_Time(10, .02);
                Sleep(0.01);
            } else {
                // turn slightly to the right
                turnLeft_Time(10, .02);
                Sleep(0.01);
            }
        }
    }
}

/*
 * =============================================
 * JUKEBOX
 * =============================================
 */

void jukebox_FindLight(int percent) {
    double cdsValue = input_Light.Value();

    motor_RightWheel.SetPercent(-1 * percent);
    motor_LeftWheel.SetPercent(-1 * percent);

    while ((abs(input_Light.Value() - cdsValue)) < 1.0) {
    }
    motor_RightWheel.Stop();
    motor_LeftWheel.Stop();
}


int jukebox_DetectColor() {
    int color;
    Sleep(1.0);
    bool colorFound = false;
    while (!colorFound) {
        LCD.WriteLine("test color: ");
        LCD.WriteLine(input_Light.Value());
        if (abs(input_Light.Value() - RED_RANGE) < 0.2) {
            // If red is detected, color is 0
            LCD.WriteLine("Color: Red");
            LCD.WriteLine(input_Light.Value());
            color = 0;
            colorFound = true;
        } else if (input_Light.Value() > 0.45 && input_Light.Value() < 1.3) {
            // If blue is detected, color is 1
            LCD.WriteLine("Color: Blue");
            LCD.WriteLine(input_Light.Value());
            color = 1;
            colorFound = true;
        }
    }
    return color;
}

void start_DetectColor() {
    Sleep(1.0);
    bool colorFound = false;
    LCD.WriteLine("Waiting for start");
    while (!colorFound) {
        if (abs(input_Light.Value() - RED_RANGE) < 0.15) {
            LCD.WriteLine("Start");
            colorFound = true;
        }
    }
}

/*
 * =============================================
 * ROBOT ARM
 * =============================================
 */

void arm_DepositTray() {
    servo_Arm1.SetDegree(110.0);
    Sleep(0.2);
    servo_Arm1.SetDegree(130.0);
    Sleep(0.5);
    servo_Arm1.SetDegree(85);
    Sleep(0.5);
    servo_Arm1.SetDegree(90);
}

void arm_SlideTicket() {
    servo_Arm2.SetDegree(70);
}

void arm_FlipBurger() {
    servo_Arm2.SetDegree(140);
    Sleep(1.0);
}
void arm_FlipLeverDown() {
    servo_Arm2.SetDegree(90);
}

void arm_FlipLeverUp() {
    servo_Arm2.SetDegree(120);
}

/*
 * =============================================
 * LINE FOLLOWING
 * =============================================
 */
void line_FollowBackward() {
    Sleep(1.0);
    bool exit = false;
    float left;
    float middle;
    float right;
    while (!exit) {
        left = input_leftOpto.Value();
        middle = input_middleOpto.Value();
        right = input_rightOpto.Value();

        // Test to see if black has been passed
        if (left < OPTO_THRESHOLD && middle < OPTO_THRESHOLD && right < OPTO_THRESHOLD) {
            exit = true;
        }

        if (right > OPTO_THRESHOLD || (middle < OPTO_THRESHOLD && left < OPTO_THRESHOLD)) {
            motor_LeftWheel.SetPercent(-10);
            motor_RightWheel.SetPercent(-15);
            Sleep(.5);
        } else if (left > OPTO_THRESHOLD || (middle < OPTO_THRESHOLD && right < OPTO_THRESHOLD)) {
            motor_LeftWheel.SetPercent(-15);
            motor_RightWheel.SetPercent(-10);
            Sleep(.5);
        } else {
            motor_LeftWheel.SetPercent(-15);
            motor_RightWheel.SetPercent(-15);
            Sleep(.5);
        }

    }
}

void line_FollowForward() {
    bool exit = false;
    float left;
    float middle;
    float right;
    while (!exit) {
        left = input_leftOpto.Value();
        middle = input_middleOpto.Value();
        right = input_rightOpto.Value();

        // Test to see if black has been passed
        if (left < OPTO_THRESHOLD && middle < OPTO_THRESHOLD && right < OPTO_THRESHOLD) {
            exit = true;
        }

        if (right > OPTO_THRESHOLD || (middle < OPTO_THRESHOLD && left < OPTO_THRESHOLD)) {
            motor_LeftWheel.SetPercent(15);
            motor_RightWheel.SetPercent(10);
            Sleep(.5);
        } else if (left > OPTO_THRESHOLD || (middle < OPTO_THRESHOLD && right < OPTO_THRESHOLD)) {
            motor_LeftWheel.SetPercent(10);
            motor_RightWheel.SetPercent(15);
            Sleep(.5);
        } else {
            motor_LeftWheel.SetPercent(15);
            motor_RightWheel.SetPercent(15);
            Sleep(.5);
        }
    }
}

void line_Find() {
    bool found = false;
    float left;
    float middle;
    float right;
    while (!found) {
        left = input_leftOpto.Value();
        middle = input_middleOpto.Value();
        right = input_rightOpto.Value();
        motor_LeftWheel.SetPercent(20);
        motor_RightWheel.SetPercent(20);
        Sleep(.2);
        if (left > OPTO_THRESHOLD || middle > OPTO_THRESHOLD || right > OPTO_THRESHOLD) {
            found = true;
        }
    }
}

/*
 * Main function
 */
int main(void) {
    /*
     * Declare x and y for touch input
     */
    float x,y;

    /*
     * Variables
     */
    int percent = 50;
    //int encoderCount = 16;

    /*
     * Initialize values
     */
    LCD.Clear(FEHLCD::Black);
    LCD.SetFontColor(FEHLCD::White);
    servo_Arm1.SetMin(MINARM1);
    servo_Arm2.SetMax(MAXARM1);
    servo_Arm2.SetMin(MINARM2);
    servo_Arm2.SetMax(MAXARM2);
    servo_Arm1.SetDegree(110);
    servo_Arm2.SetDegree(170);
    // arm 2 straight up is 170
    int iceCream = 0;

    /*
     *  Define Locations
     */
    Location location_Tray{18, 39.0, 90.0};
    Location location_Ticket{30.0, 43.0, 0.0};
    Location location_IceCream0{14.0, 53.0, 135.0};
    Location location_IceCream1{16.8, 56.4, 135.0};
    Location location_IceCream2{19.5, 59.5, 135.0};
    Location location_Burger{23.0, 60.0, 90.0};
    Location location_Jukebox{2.0, 2.0, 2.0};
    /*
     * Initialize RPS
     */
    RPS.InitializeTouchMenu();

    // Uncomment this block to test RPS coordinates
/*
    while(!LCD.Touch(&x,&x)) {
        LCD.WriteRC(RPS.X(),2,12); //update the x coordinate
        LCD.WriteRC(RPS.Y(),3,12); //update the y coordinate
        LCD.WriteRC(RPS.Heading(),4,12); //update the heading

        Sleep(10); //wait for a 10ms to avoid updating the screen too quickly
    }
    while(LCD.Touch(&x,&x));
*/

    /*
     * Wait for color to start
     */
    start_DetectColor();
    LCD.WriteLine("Battery:");
    LCD.WriteLine(Battery.Voltage());
    LCD.WriteLine("Icecream lever:");
    iceCream = RPS.GetIceCream();
    LCD.WriteLine(iceCream);


    /*
     * =============================================
     * Begin script
     * =============================================
     */

    /*
     * Tray
     */
    //move to ramp
    moveForward_Time(percent, 12.0);
    turnRight_Time(percent, 0.5);
    rps_checkHeading(90.0);
    //go up ramp
    moveForward_Time(percent, 28);
    rps_checkHeading(90.0);
    rps_MoveToPositiveY(15, location_Tray.getY());
    // deposit tray
    arm_DepositTray();
    LCD.WriteLine(RPS.Y());

    /*
     * Ticket
     */
    moveForward_Time(percent, 3.0);
    turnRight_Time(percent, TIME_ROTATE);
    rps_checkHeading(0.0);
    moveForward_Time(percent, 7.0);
    // get arms ready for ticket
    servo_Arm2.SetDegree(90.0);
    Sleep(.2);
    servo_Arm1.SetDegree(180.0);
    Sleep(.2);
    servo_Arm2.SetDegree(150.0);
    rps_MoveToPositiveX(percent, location_Ticket.getX());
    servo_Arm2.SetDegree(170.0);
    Sleep(.5);
    moveBackward_Time(percent, 13.0);

    /*
     * Ice cream
     */
    Sleep(1.0);
    servo_Arm2.SetDegree(90.0);
    Sleep(0.2);
    servo_Arm1.SetDegree(90.0);
    Sleep(0.2);
    servo_Arm2.SetDegree(170.0);
    turnLeft_Time(percent, TIME_ROTATE);
    rps_checkHeading(90.0);

    if (iceCream == 2) {
        moveForward_Time(percent, 12.0);
        rps_MoveToPositiveY(15, 59.5);
        turnLeft_Time(percent, TIME_ROTATE / 2);
        rps_checkHeading(135.0);
        moveForward_Time(percent, 9.0);
    } else if (iceCream == 1) {
        moveForward_Time(percent, 7.0);
        rps_MoveToPositiveY(15, 57);
        turnLeft_Time(percent, TIME_ROTATE / 2);
        rps_checkHeading(135.0);
        moveForward_Time(percent, 7.0);
    } else {
        moveForward_Time(percent, 9.0);
        turnLeft_Time(percent, TIME_ROTATE / 2);
        rps_checkHeading(135.0);
        moveForward_Time(percent, 9.0);
    }

    arm_FlipLeverDown();
    Sleep(.2);
    moveBackward_Time(percent, 2.0);
    servo_Arm2.SetDegree(65);
    moveForward_Time(percent, 2.0);
    Sleep(7.0);
    arm_FlipLeverUp();
    Sleep(0.2);

    /*
     * Burger
     */
    // move to burger
    servo_Arm1.SetDegree(115);
    servo_Arm2.SetDegree(0);
    turnRight_Time(40, 1.0); //.8
    moveForward_Time(percent, 4.2); //5
    turnLeft_Time(40, 0.9); //.8
    moveForward_Time(percent, 11.05); //15
    // flip burger
    arm_FlipBurger();

    /*
     * Jukebox
     */
    // Move backward until the light is detected
    jukebox_FindLight(percent);

    // Detect the light color
    LCD.WriteLine("Detecting color...");
    int color = jukebox_DetectColor();

    // Align the correct black line
    if (color == 0) {
        //red
        LCD.WriteLine("RED");
        turnRight(percent, TIME_ROTATE / 2);
        moveBackward(percent, TIME_INCH * 2);
        turnLeft(percent, TIME_ROTATE / 2);
    } else if (color == 1) {
        //blue
        LCD.WriteLine("BLUE");
        turnLeft(percent, TIME_ROTATE / 2);
        moveBackward(percent, TIME_INCH * 2);
        turnRight(percent, TIME_ROTATE / 2);
    }
    // Move forward to press button
    moveBackward(percent, TIME_INCH * 8);

    /*
     * Final button
     */
    moveBackward_Time(percent, 10.0);
    servo_Arm2.SetDegree(170.0);
    turnLeft_Time(percent, TIME_ROTATE / 2);
    rps_checkHeading(180.0);
    rps_MoveToNegativeX(15, 17.0);
    turnLeft_Time(percent, TIME_ROTATE);
    rps_checkHeading(270.0);
    rps_MoveToNegativeY(15, 46.0);
    rps_checkHeading(270.0);
    moveForward_Time(percent, 30.0);
    rps_MoveToNegativeY(15, 15.0);
    turnLeft_Time(percent, TIME_ROTATE / 2);
    rps_checkHeading(315.0);
    moveForward_Time(percent, 15.0);

    /*
     * =============================================
     * End script
     * =============================================
     */

    return 0;
}
